---
title: 'Containers routing'
taxonomy:
    category:
        - docs
---

Routing is the ability to expose a container on a publicly accessible URL. This is configured in the `docker-compose.yml` file for each container. Protocode offers two methods for managing this exposure:

## Presence of the `VIRTUAL_HOST` variable

If a container has a `VIRTUAL_HOST` variable, Protocode will automatically generate a preview URL:

[prism classes="language-yaml line-numbers" highlight="6,7"]
version: "3"
services:
    app:
        image: "node:16"
        environment:
            VIRTUAL_HOST: "app-my-repository.${ENVIRONMENT_URL}"
[/prism]

!!! No matter the value entered in the VIRTUAL_HOST variable, it will be replaced during environment creation based on the URL of the server that will host it.

## Port Allocation

If a container specifies a port allocation on the host machine, Protocode will also generate a preview URL:

[prism classes="language-yaml line-numbers" highlight="6"]
version: "3"
services:
    app:
        image: "node:16"
        ports:
        	- "8080:8080"
[/prism]

!!! One particularity to note: although your configuration allocates a host machine port to your container, the URL generated by Protocode will always be on port 443. The environment will then internally redirect this call to the port expected by the container.

## Container URLs

Protocode constructs container URLs according to the following convention:

`SERVICE_NAME`-`REPOSITORY_SLUG`.`ENVIRONMENT_URL`

The first two parts are easily deduced:
* **SERVICE_NAME**: This is the name of the container in the docker-compose.yml file. In the previous example, it's "app"..
* **SLUG_DU_REPOSITORY**: This comes from the name of the Git repository, with the .git extension removed. Example: for `githost.ext/me/my-repository.git`, the slug will be `my-repository`.

The last part, `ENVIRONMENT_URL`, is dynamically determined by Protocode and can vary based on several parameters (environment namespace, server, etc.). However, it is accessible in every environment via the `ENVIRONMENT_URL` environment variable.

## Communication Between Services

If one service needs to communicate with another (for example, a frontend and an API), it can use ENVIRONMENT_URL to dynamically construct URLs:

[prism classes="language-yaml line-numbers" highlight="9,15"]
# In the docker-compose file of the repository githost.ext/me/my-repository.git
version: "3"

services:
    api:
        image: "php:8.0"
        environment:
            VIRTUAL_HOST: "api-my-repository.${ENVIRONMENT_URL}" #The API must be exposed
            FRONT_URL: "front-my-repository.${ENVIRONMENT_URL}" # It needs the frontend URL

    front:
        image: "node:16"
        environment:
            VIRTUAL_HOST: "front-my-repository.${ENVIRONMENT_URL}" # The frontend must be exposed
            API_URL: "api-my-repository.${ENVIRONMENT_URL}" #It needs the API URL
[/prism]
